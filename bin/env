#!/usr/bin/env bash

# Oh-My-Emacs
# export OME_BIN=$(dirname $(readlink -f $0))
# export OME_ROOT=$OME_BIN/..

export OME_ROOT=$HOME/.oh-my-emacs
export OME_BIN=$OME_ROOT/bin
export PATH=$OME_BIN:$PATH

export DEV_ROOT=$HOME/.dev
export WS_BIN=$HOME/workspace/bin
export BOOK_ROOT=$HOME/book
export PROJ_ROOT=$HOME/projects

export CACHE=$OME_ROOT/cache
export APP_HOME=$CACHE/apps
export ZIP_HOME=$CACHE/apps-zip

# Shell
export SHELL_NAME=ps |  grep $$  |  awk '{print $4}'

# User Settings
export PATH=$HOME/bin:$HOME/.local/bin:$PATH:$WS_BIN

################################################################################
# Ocaml: OPAM configuration
case "$SHELL_NAME" in
    "zsh")
	. $HOME/.opam/opam-init/init.zsh > /dev/null 2> /dev/null || true
	;;
    "bash")
	. $HOME/.opam/opam-init/init.sh > /dev/null 2> /dev/null || true
	;;
    "csh")
	. $HOME/.opam/opam-init/init.csh > /dev/null 2> /dev/null || true
	;;
esac

# LLVM
export LLVM_BIN=$HOME/.llvm/bin
export PATH=$LLVM_BIN$PATH

# Cmake
export CMAKE_BIN=$DEV_ROOT/cmake/bin
export PATH=$CMAKE_BIN:$PATH

# rtags
export RTAGS_BIN=$DEV_ROOT/rtags/build/bin
export PATH=$RTAGS_BIN:$PATH

# Pyenv
export PYENV_ROOT=$DEV_ROOT/pyenv
export PATH=$PYENV_ROOT/bin:$PATH
if command -v pyenv 1>/dev/null 2>&1; then
    eval "$(pyenv init -)"
fi
# export PYTHON_BUILD_MIRROR_URL="http://mirrors.sohu.com/python/2.7.12/"

# gyp
export GYP_BIN=$DEV_ROOT/gyp
export PATH=$GYP_BIN:$PATH

# SDKMAN
source $HOME/.sdkman/bin/sdkman-init.sh

# Roswell
export ROSWELL_BIN=/home/`whoami`/.roswell/bin
export PATH=$ROSWELL_BIN:$PATH

# ROS
case "$SHELL_NAME" in
    "zsh")
	source /opt/ros/kinetic/env.zsh
	source $HOME/catkin_ws/devel/env.zsh
	;;
    "bash")
	source /opt/ros/kinetic/env.bash
	source $HOME/catkin_ws/devel/env.bash
	;;
esac
export PATH=$PATH:$HOME/catkin_ws/bin

# Cyberman
export PATH=$HOME/Cyberman:$PATH
################################################################################
# Cpp: cquery
export CQUERY_BIN=$HOME/.cquery
export PATH=$CQUERY_BIN:$PATH

# Nodejs : must put to .profile or .bashrc/.zshrc
# if ! command -v nvm >/dev/null 2>&1; then
# export NVM_DIR="$HOME/.nvm"
# [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
# [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
# fi

# Golang
export GOROOT=$DEV_ROOT/go
export GOPATH=$HOME/goprojects
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN:$GOROOT/bin

# export GOROOT_BOOTSTRAP=$DEV_ROOT/go
# export GOOS=linux
# export GOARCH=amd64

# Rust
# [ -s "$HOME/.cargo/env" ] && \. "$HOME/.cargo/env"
# if [ -e $HOME/.cargo/env ]; then
# source $HOME/.cargo/env
# export RUST_SRC_PATH="$(rustc --print sysroot)/lib/rustlib/src/rust/src"
# fi
export PATH=$HOME/.cargo/bin:$PATH
export RUST_SRC_PATH="$(rustc --print sysroot)/lib/rustlib/src/rust/src"

# Nim-lang
export PATH=$HOME/.nimble/bin:$PATH

# Erlang
export PATH=$DEV_ROOT/erlang_otp/bin:$PATH

# Elixir
export PATH=$DEV_ROOT/elixir/bin:$PATH

# mu4e
export PATH=$HOME/.mu/bin:$PATH
################################################################################

# CURRENT_DIR=$(dirname $(readlink -f $0))
# echo $CURRENT_DIR
source lib
source tool
source proj
